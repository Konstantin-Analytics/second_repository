Ссылка на обучение по работе с Git: https://practicum.yandex.ru/trainer/git-basics/lesson/cc37a4db-7f30-4210-94d2-f3044efecc41/

[Link](https://practicum.yandex.ru/trainer/git-basics/lesson/cc37a4db-7f30-4210-94d2-f3044efecc41/ "Курс - 'Начало работы с Git'")

## Инициализируем репозиторий

### Сделать папку репозиторием — git init

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»)  
Вы можете создать папку в любом месте на компьютере.  
Не рекомендуется создавать репозиторий Git внутри другого Git-репозитория. Это может вызывать проблемы с отслеживанием изменений.  

```bash
$ cd ~/<папка с репозиторием> # переходим в нужную папку
$ git init # создаём репозиторий
```

### «Разгитить» папку, если что-то пошло не так, — rm -rf .git

Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку .git.

```bash
$ cd <папка с репозиторием> # перешли в папку
$ rm -rf .git # удалили подпапку .git
```

Разберём подробнее, что такое -rf:  
- ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
- ключ -f (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».


Будьте осторожны: в подпапке .git хранится история изменений. Если удалить .git, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.

## Добавляем файлы в репозиторий

### Подготовить файлы к сохранению — git add

Создаём/копируем нужные файлы в папку репозитория. Проверяем статус.
Состояние untracked значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.

```bash
$ git add --all # подготовили к сохранению все файлы в репозитории

$ git add <название файла> # Добавлять файлы можно и по одному, без ключа --all

$ git add . # Или добавить всю текущую папку. Обратиться к текущей папке в Bash позволяет точка (.)
```

* Команда git add позволяет подготовить файл к сохранению.
* Команда git add --all подготовит к сохранению сразу все файлы.
* С помощью git add . можно добавить в репозиторий текущую папку со всеми файлами.

>Чем отличается запоминание от сохранения?
>Команда git add не сохраняет содержимое файлов в репозитории. Само сохранение, или фиксацию состояния файлов, называют коммитом (от англ. commit — «совершать», «фиксировать»). «Сделать коммит» значит сохранить текущую версию файла. 
>Если провести аналогию, команду git add можно сравнить с добавлением товаров в корзину в интернет-магазине, а коммит — с оформлением и оплатой заказа.

## Делаем первый коммит

>Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться». Это как если бы вы могли выполнить операцию Ctrl+Z для целой папки (репозитория).

>Сделать коммит можно командой git commit c ключом -m (от англ. message — «сообщение»), который присваивает коммиту сообщение.

```bash
$ git commit -m 'сообщение с пояснениями, в чём именно состояли изменения'
```

После нажатия Enter текущая версия файлов будет сохранена в репозитории с сообщением  
**Коммит** (по названию команды git commit) — это по сути список файлов с их контентом.

### Ещё раз о разнице между git add и git commit

Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение. 

>Проведём ещё одну аналогию — с фотографией.
>Сначала вы просите друзей встать в ряд — это команда git add. И только после того, как все заняли свои места, поправили волосы и улыбнулись, вы нажимаете кнопку и делаете снимок — это команда git commit. Сам получившийся снимок и будет коммитом. На этой фотографии с обратной стороны ещё есть подпись - сообщение.

## Просматриваем историю коммитов

```bash
$ git log # Просмотреть историю коммитов
```



## Связываем локальный и удалённый репозитории

### Привязать удалённый репозиторий к локальному — git remote add

Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL.

```bash
$ cd ~/<папка с репозиторием>
$ git remote add origin <URL> # пример URL: git@github.com:Konstantin-Analytics/second_repository.git
```

>*origin* (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). 

### Убедиться, что репозитории связаны, — git remote -v

```bash
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```

>В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.
>Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.


## Синхронизируем локальный и удалённый репозитории

### Основная ветка

Если коммит — это снимок состояния файлов, то ветка — временна́я шкала, на которой расположены эти снимки. Ветка всегда начинается от одного из коммитов.  
В репозитории может существовать сразу несколько веток — параллельных историй изменений. Также они могут соединяться друг с другом.  
Самая первая ветка в репозитории появляется автоматически и называется main (англ. «основная») или master. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него.  

### Отправить изменения на удалённый репозиторий — git push

>Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью git add, закоммитили их с комментарием командой git commit -m. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда git push (от англ. push — «толкать»).>

>В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.>

```bash
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте заменить main на master.
```
